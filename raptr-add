#!/usr/bin/env bash
set -e
script_name="$(basename "$BASH_SOURCE")"
script_dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

while [[ "$#" > 0 ]]; do
	case "$1" in
		-t|--target|--target=) raw_target="$2"; shift ;; # TODO: allow multiple targets
		-p|--package|--package=) raw_package="$2"; shift ;;
		*) shift ;;
	esac
done

function assert_working_directory() {
	[ ! -d ./dists ] && echo "The command must be executed inside of an active repository." >&2 && return 1
	[ ! -d ./pool ] && echo "The command must be executed inside of an active repository." >&2 && return 1
	return 0
}
function assert_arguments() {
	[ -z "$1" ] && echo "Missing required target to which package should be added." >&2 && return 1
	[ -z "$2" ] && echo "Missing required package to add." >&2 && return 1
	return 0
}
function expand_target() {
	local available_targets="$(cd dists; find . -mindepth 2 -maxdepth 2 -type d | \
		sed -r 's/\.\/(.*?)/\1 /g' | tr '\n' ' ')"
	local target_input="$1"

	# TODO: avoid * expansion but allow looping (use IFS?)
	for t in "${target_input}"; do
		if [ "${t}" == "*/*" ] || [ "${t}" == "*" ]; then echo -n "${available_targets} "
		elif [[ " ${available_targets} " == *" ${t} "* ]]; then echo -n "${t} "
		elif [[ "${t}" == "*/"* ]]; then echo -n "$(expand_target_prefix "${t:2}")"
		elif [[ "${t}" == *"/*" ]]; then echo -n "$(expand_target_suffix "${t:0:-2}")"
		fi
	done
	
	return 0
}
function expand_target_prefix() {
	local available_archives="$(cd dists; ls -d * | tr '\n' ' ')"
	local section="$1"

	[ -z "${section}" ] && echo "The specified section '${section}' does not exist." >&2 && return 1
	for archive in ${available_archives}; do
		[ ! -d "dists/${archive}/${section}" ] && \
			echo "The specified section '${section}' does not exist." >&2 && return 1
		echo -n "${archive}/${section} "
	done

	return 0
}
function expand_target_suffix() {
	local available_sections="$(cd pool; ls -d * | tr '\n' ' ' )"
	local archive="$1"

	[ -z "${archive}" ] && echo "The specified archive '${archive}' does not exist." >&2 && return 1
	for section in ${available_sections}; do
		[ ! -d "dists/${archive}/${section}" ] && \
			echo "The specified archive '${archive}' does not exist." >&2 && return 1
		echo -n "${archive}/${section} "
	done
	
	return 0
}
function generate_package_indexes() {
	local package="$1"
	local targets="$2"

	[ -n "${targets}" ] && echo "Targets: ${targets}"
	[ -z "${targets}" ] && echo "There are no targets." >&2 && return 1

	for t in ${targets}; do
		local archive="${t%/*}"
		local section="${t#*/}"
		index_package "${package}" "${archive}" "${section}"
	done

	return 0
}
function index_package() {
	local package_path="$1"
	local package_extension="${package_path##*.}"

	if [[ "${package_path}" == *"/*" ]]; then index_package_directory "$@"
	elif [ -d "${package_path}" ]; then index_package_directory "$@"
	elif [ "${package_extension}" == "deb" ]; then index_binary_package "$@"
	elif [ "${package_extension}" == "dsc" ]; then index_source_package "$@"
	else echo "Could not determine package contents; make sure it's a 'deb' or 'dsc' file." >&2 && return 1
	fi

	return 0
}
function index_package_directory() {
	local package_path="$1"
	local archive="$2"
	local section="$3"
	local filenames="$(ls ${package_path})"

	[ -z "${filenames}" ] && \
		echo "The directory '${package_path}' does not exist or does not contain any files." >&2 && return 1

	for filename in ${package_path}; do
		[ ! -f "${filename}" ] && continue
		local extension="${filename##*.}"
		[ "${extension}" == "deb" ] || [ "${extension}" == "dsc" ] && \
			index_package "${filename}" "${archive}" "${section}"
	done

	return 0
}
function index_source_package() {
	local package_path="$1"
	local package_filename="$(basename "${package_path}")"
	local archive="$2"
	local section="$3"

	[ ! -f "${package_path}" ] && echo "The binary package '${package_path}' does not exist." >&2 && return 1
	eval "$(extract_package_name_and_version "${package_path}")"

	local sources_path="dists/${archive}/${section}/source"
	local sources_index_path="$(readlink -m "${sources_path}/Sources")"
	local pool_directory="pool/${section}/${package_name::1}/${package_name}"
	local workspace_root="/tmp/raptr/workspaces/$$"
	local workspace_path="${workspace_root}/${pool_directory}"
	local package_directory="$(dirname "${package_path}" )"

	echo "Adding '${package_name}' to '${sources_path}'."
	[ -f "${sources_index_path}" ] && [ -n "$(grep "${package_filename}" "${sources_index_path}")" ] \
		&& echo "Source package already added to target directory '${sources_path}'; skipping." >&2 && return 0

	mkdir -p "${sources_path}" "${workspace_path}" "${pool_directory}"
	ln -s "${package_path}" "${workspace_path}"
	for f in ${source_filenames}; do ln -s "${package_directory}/${f}" "${workspace_path}"; done
	$( cd "${workspace_root}"; dpkg-scansources "${pool_directory}" >> "${sources_index_path}" )
	gzip_and_bzip_file "${sources_index_path}"
	cp "${workspace_path}"/* "${pool_directory}"
	rm -rf "${workspace_root}"

	return 0
}
function index_binary_package() {
	local package_path="$1"
	local archive="$2"
	local section="$3"

	[ ! -f "${package_path}" ] && echo "The binary package '${package_path}' does not exist." >&2 && return 1
	eval "$(extract_package_name_and_version "${package_path}")"

	local available_cpus="$(cd "dists/${archive}/${section}"; ls -d binary-* 2> /dev/null | \
		sed 's/binary-\(.*\)/\1/' | tr '\n' ' ' )"

	if [ "${package_cpu}" == "all" ]; then
		for each_cpu in ${available_cpus};
			do index_binary_package_architecture "$@" "${package_name}" "${each_cpu}";
		done
	elif [[ ! " ${available_cpus} " == *" ${package_cpu} "* ]]; then
		echo "The package's target architecture is not supported; skipping" >&2 && return 0 # not an error
	else
		index_binary_package_architecture "$@" "${package_name}" "${package_cpu}"
	fi

	return 0
}
function extract_package_name_and_version() {
	local package_path="$1"
	local package_filename="$(basename "${package_path}")"
	local package_extension="${package_filename##*.}"
	local filename_without_extension="${package_filename%.*}"
	local package_meta=( $(echo "${filename_without_extension}" | tr "_" " ") )

	[ "${package_extension}" == "dsc" ] && \
		local source_filenames="$(cat "${package_path}" | \
			sed -n 's/ [a-z0-9]\{32\} [0-9]\+ \(.*\)/\1/p' | tr "\n" " " )"

	cat <<-EOF
		local package_filename="${package_filename}"
		local package_name="${package_meta[0]}"
		local package_extension="${package_extension}"
		local package_version="${package_meta[1]}"
		local package_cpu="${package_meta[2]}"
		local source_filenames="${source_filenames}"
	EOF
}
function index_binary_package_architecture() {
	local package_path="$1"
	local package_filename="$(basename "${package_path}")"
	local archive="$2"
	local section="$3"
	local package_name="$4"
	local package_cpu="$5"

	local target_path="dists/${archive}/${section}"
	local content_filename="${target_path}/Contents-${arch}"

	local cpu_path="${target_path}/binary-${package_cpu}"
	local packages_index_path="$(readlink -m "${cpu_path}/Packages")"

	local pool_directory="pool/${section}/${package_name::1}/${package_name}"
	local workspace_root="/tmp/raptr/workspaces/$$"
	local workspace_path="${workspace_root}/${pool_directory}"

	echo "Adding '${package_name}' to '${cpu_path}'."
	[ -f "${packages_index_path}" ] && [ -n "$(grep "${package_filename}" "${packages_index_path}")" ] \
		&& echo "Binary package already added to target directory '${cpu_path}'; skipping." >&2 && return 0

	mkdir -p "${pool_directory}" "${workspace_path}"
	ln -s "${package_path}" "${workspace_path}"
	$( cd "${workspace_root}"; dpkg-scanpackages "${pool_directory}" >> "${packages_index_path}" )
	gzip_and_bzip_file "${packages_index_path}"

	# TODO: generate *optional* dists/(archive)/(section)/Contents-(cpu) file:
	# https://wiki.debian.org/RepositoryFormat#A.22Contents.22_indices
	# then gzip, bzip2 Contents-(cpu) file

	rm -rf "${workspace_root}"
	[ ! -f "${pool_directory}/${package_filename}" ] && cp "${package_path}" "${pool_directory}"

	return 0
}
function gzip_and_bzip_file() {
	local uncompressed_file="$1"
	gzip -c9 "${uncompressed_file}" > "${uncompressed_file}.gz"
	bzip2 -c9 "${uncompressed_file}" > "${uncompressed_file}.bz2"
	return 0
}

assert_working_directory
assert_arguments "${raw_target}" "${raw_package}"
expanded_targets=$(expand_target "${raw_target}" )
generate_package_indexes "${raw_package}" "${expanded_targets}"

exit 0
