#!/usr/bin/env bash
set -e
script_name="$(basename "$BASH_SOURCE")"
script_dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

while [[ "$#" > 0 ]]; do
	case "$1" in
		-t|--target|--target=) raw_target="$2"; shift ;; # TODO: allow multiple targets
		-p|--package|--package=) raw_package="$2"; shift ;;
		*) shift ;;
	esac
done

function assert_working_directory() {
	[ ! -d ./dists ] && echo "The command must be executed inside of an active repository." >&2 && return 1
	[ ! -d ./pool ] && echo "The command must be executed inside of an active repository." >&2 && return 1
	return 0
}
function assert_arguments() {
	[ -z "$1" ] && echo "Missing required target to which package should be added." >&2 && return 1
	[ -z "$2" ] && echo "Missing required package to add." >&2 && return 1
	return 0
}
function expand_target() {
	local available_targets="$(cd dists; find . -mindepth 2 -maxdepth 2 -type d | \
		sed -r 's/\.\/(.*?)/\1 /g' | tr '\n' ' ')"
	local target_input="$1"

	# TODO: avoid * expansion but allow looping (use IFS?)
	for t in "${target_input}"; do
		if [ "${t}" == "*/*" ] || [ "${t}" == "*" ]; then echo -n "${available_targets} "
		elif [[ " ${available_targets} " == *" ${t} "* ]]; then echo -n "${t} "
		elif [[ "${t}" == "*/"* ]]; then
			local expanded=$(expand_target_prefix "${t:2}"])
			echo -n "${expanded}"
		elif [[ "${t}" == *"/*" ]]; then
			local expanded=$(expand_target_suffix "${t:0:-2}")
			echo -n "${expanded}"
		fi
	done
	
	return 0
}
function expand_target_prefix() {
	local available_archives="$(cd dists; ls -d * | tr '\n' ' ')"
	local section="$1"

	[ -z "${section}" ] && echo "The specified section '${section}' does not exist." >&2 && return 1
	for archive in ${available_archives}; do
		[ ! -d "dists/${archive}/${section}" ] && \
			echo "The specified section '${section}' does not exist." >&2 && return 1
		echo -n "${archive}/${section} "
	done

	return 0
}
function expand_target_suffix() {
	local available_sections="$(cd pool; ls -d * | tr '\n' ' ' )"
	local archive="$1"

	[ -z "${archive}" ] && echo "The specified archive '${archive}' does not exist." >&2 && return 1
	for section in ${available_sections}; do
		[ ! -d "dists/${archive}/${section}" ] && \
			echo "The specified archive '${archive}' does not exist." >&2 && return 1
		echo -n "${archive}/${section} "
	done
	
	return 0
}
function index_packages() {
	local package="$1"
	local targets="$2"

	[ -n "${targets}" ] && echo "Targets: ${targets}"
	[ -z "${targets}" ] && echo "There are no targets." >&2 && return 1

	for t in ${targets}; do
		local archive="${t%/*}"
		local section="${t#*/}"
		index_package "${package}" "${archive}" "${section}"
	done

	return 0
}
function index_package() {
	local package="$1"
	local archive="$2"
	local section="$3"

	# TODO: determine the package to add; it could be a:
	# 1. native source package
	# 2. non-native source package
	# 3. native, architecture-specific, binary package, e.g. pkg_1.0.0-1ubuntu1~asdf_amd64.deb
	# 4. non-native architecture-specific, binary package, e.g. pkg_1.0.0~asdf_i386.deb
	# 5. native, architecture-independent, binary package, e.g. pkg_1.0.0~asdf_all.deb
	# 6. non-native, architecture-independent, binary package, e.g. pkg_1.0.0-1ubuntu1~asdf_all.deb

	# TODO: what characters are allowed in the version field of the filename? plus characters?


	return 0
}
function discover_package() {
	local package_path="$1"
	local package_extension="${package_path##*.}"

	if [[ "${package_path}" == *"/*" ]]; then discover_package_directory "${package_path}"
	elif [ "${package_extension}" == "deb" ]; then discover_binary_package "${package_path}"
	elif [ "${package_extension}" == "dsc" ]; then discover_source_package "${package_path}"
	else echo "Could not determine package contents; make sure it's a 'deb' or 'dsc' file." >&2 && return 1
	fi

	return 0
}
function discover_package_directory() {
	return 0
}
function discover_source_package() {
	local package_filename="$(basename "${package_path}")"
	return 0
}
function discover_binary_package() {
	local package_filename="$(basename "${package_path}")"
	return 0
}
function gzip_and_bzip_file() {
	local uncompressed_file = "$1"
	gzip -c9 "${uncompressed_file}" > "${uncompressed_file}.gz"
	bzip2 -c9 "${uncompressed_file}" > "${uncompressed_file}.bz2"
	return 0
}

assert_working_directory
assert_arguments "${raw_target}" "${raw_package}"
expanded_targets=$(expand_target "${raw_target}" )
index_packages "${package}" "${expanded_targets}"
exit 0

##################################################################################################

[ -z "$(ls "${package}" 2> /dev/null)" ] && echo "The package to add '${package}' could not be found." && exit 1
filename="$(basename "${package}")"
package_name=$(echo "${filename}" | sed -n 's/\([A-Za-z0-9.-]\+\)_.*\.\(deb\|dsc\)/\1/p')
package_extension="${filename##*.}"
[ -z "${package_name}" ] && echo "The file specified package '${package}' doesn't appear to be a debian package." && exit 1

target_directory="dists/${archive}/${section}"
pool_directory="pool/${section}/${package_name::1}/${package_name}"
workspace_directory="workspace/${pool_directory}"
mkdir -p "${pool_directory}" "${workspace_directory}"

# TODO: what about architecture: all, e.g. bash and python scripts?

if [ "${package_extension}" == "deb" ]; then
	arch=$(basename "${package}" | sed -n 's/.*_.*_\([a-z0-9]\+\).\(deb\|dsc\)/\1/p')
	binary_directory="${target_directory}/binary-${arch}"
	packages_filename="${binary_directory}/Packages"
	content_filename="${target_directory}/Contents-${arch}"

	[ ! -d "${binary_directory}" ] \
		&& echo "Architecture '${arch}' does not exist in the repository." && exit 1

	[ -n "$(grep "${filename}" "${packages_filename}")" ] \
		&& echo "Binary package already added; skipping." && exit 0

	cp "${package}" "${workspace_directory}"
	$(cd workspace; dpkg-scanpackages "${pool_directory}" >> "../${packages_filename}")
	gzip_and_bzip_file "${packages_filename}"

	# TODO: read contents of deb file and append to Contents-$arch then sort by filename | unique

	mv "${workspace_directory}"/* "${pool_directory}"
	$(cd workspace; rmdir "${pool_directory}")
elif [ "${package_extension}" == "dsc" ]; then
	package_without_extension="${package%.*}"
	source_directory="${target_directory}/source"
	sources_filename="${source_directory}/Sources"

	[ ! -d "${source_directory}" ] \
		&& echo "Source architecture doesn't exist in the repository." && exit 1

	[ -n "$(grep "${filename}" "${sources_filename}")" ] \
		&& echo "Source package already added; skipping." && exit 0

	# TODO: copy associated files: typically packagename_version.orig.* (tar.gz, tar.bz2, etc.) and package (without extension).debian.tar.gz
	cp "${package_without_extension}".* "${workspace_directory}"
	gzip_and_bzip_file "${sources_filename}"
	$(cd workspace; dpkg-scansources "${pool_directory}" >> "../${sources_filename}")

	mv "${workspace_directory}"/* "${pool_directory}"
	$(cd workspace; rmdir "${pool_directory}")
fi

echo "Added Debian '${package_name}' package to '${section}' pool."
exit 0
