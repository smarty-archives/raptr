general workflow:
- parse deb|dsc files and check integrity (add-based operations)
- download Releases file and check download integrity? (or perform a list operation)
- download various Packages/Sources files and check download integrity
- append deb|dsc control information to respective Packages/Sources list
- generate Packages/Sources/Release files
- upload deb|dsc|tar.gz files to pool (overwriting anything already there...) (add-based operations)
- upload Packages/Sources/Release[.gpg] files


actual package name/version/architecture is our unique, primary key: http://www.aptly.info/doc/feature/duplicate/
adding a duplicate package will indicate it was skipped, exit code 0
version should be required for remove/link/unlink. It can be a specific version or "all"
  implicit behavior based upon version is too vague and therefore likely to have significant and undesirable consequences


bundle = a set of packages with the same version, e.g. liveaddress-streetapi
all files that are part of a bundle must all have the same version


// this CLI is needs some attention. It allows to much room for error with s3 paths+dist+category
raptr
   add /path/to/set/of/related/files/all/with/same/version to "s3://bucket-name/dir/dir/dir distribution category"
   remove [package-name] [version] from "s3://bucket-name/dir/dir/dir distribution category"
   link [package-name] [version] from "s3://bucket-name/dir/dir/dir distribution category" to "distribution category"
   unlink [package-name] [version] from "s3://bucket-name/dir/dir/dir distribution category"
   purge "s3://bucket-name/dir/dir/dir" # must scan for all Packages and Sources files along with entire pool directory


deb-s3 (ruby) is a good approach, but doesn't support concurrency, source packages, or the standard pool structure
it also has a ton of runtime dependencies we don't want


The following directory structure makes it easy to find a particular bundle and all files related to it for things
like linking and removing. it's also really easy to discover all files that exist as part of a particular bundle.
Pool directory structure: /pool/category/(first letter of bundle)/(bundle name)/(version)/bundle files here


during remove operations, I like the idea of removing bundles (based upon name) as well as removing specific files
based upon the filename (pkg name+verion+arch). only deb's and dsc's can be removed. orig.tar.gz can't be removed
the orig.tar.gz will be nuked during the next purge/sweep/vacuum operation.


What good is the Releases file in each distribution during normal operations? The only reason we might use it
is to discover what Packages|Sources files exist. Thus far, it doesn't appear to be helping us much.
